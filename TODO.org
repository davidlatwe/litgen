* Emacs tips

M = Alt
C = Ctrl
M-x = select / search command

C-g : quit current command

* Org mode tips
** Basics
[[https://orgmode.org/orgguide.html#Introduction][Org mode quick guide]]
Link to org [[https://orgmode.org/][mode homepage]] (M-x org-insert-link)


Tab or Shift-Tab on * to collapse locally or globally
Ctrl-Enter to enter a new title of same level below sub-hierarchy
Alt-Enter to enter a new title directly under
Alt-Up/Down to move sections

Format text: Here is *some* content, and some //italic//

** diagrams and drawings

*** With mermaid

Installed https://github.com/arnm/ob-mermaid

See doc of mermaid, run mermaid via C-c C-c
Display images via `org-display-inline-images` (M-x to select action)
Also toggle display via C-c C-x C-v (wtf is that shortcut!)


#+begin_src mermaid :file doc/diagrams/test.png
sequenceDiagram
 A-->B: Works!
 B-->C: Again!q
#+end_src

#+RESULTS:
[[file:doc/diagrams/test.png]]

*** With Plantuml


#+begin_src plantuml :file doc/diagrams/test_puml.png
title Authentication Sequence

Alice->Bob: Authentication Request
note right of Bob: Bob thinks about it
Bob->Alice: Authentication Response
#+end_src

#+RESULTS:
[[file:doc/diagrams/test_puml.png]]



** Tables: start adding | then use Tab key for magic
| Name  | Age | Sex |
|-------+-----+-----|
| David |  37 | M   |
|       |     |     |



** Lists: use Alt-Enter / use Alt-Shift-Enter (i.e M-S-RET) to  add checkboxes

- [ ] First item
- [ ]
- Second Item
- Third

Example:



** Code blocks : #+begin_src lang / #+end_src (C-C ' to edit the code block in separate buffer)

#+NAME example (optional name)
#+begin_src cpp
  int main()
  {
    return 0;

  }
#+end_src


** TODOs List (C-c C-t )

*** Item 1
*** DONE Item

CLOSED: [2022-09-18 Sun 10:54]



**** Sub Heading
**** A
   int a = 0


* srcml_cpp

** ideas / further development
*** pimpl_my_class
*** add named parameters to functions


* Litgen doc

** Diagram srcmlcpp and litgen adapted classes

Failed attempt to remove confirmation for C-c C-c
(setq org-confirm-babel-evaluate f)

#+begin_src plantuml :file packages/srcmlcpp/doc/srcml_cpp_diagram.png
  class ET.Element
  package srcmlcpp {
          class SrcmlOptions {
                  + encoding
                  +preserve_empty_lines
                  ...
          }

          class SrcmlXmlWrapper {
                  + options: SrcmlOptions
                  + srcml_xml: ET.Element
                  + parent: opt[SrcmlXmlWrapper]

                  + str_code_verbatim()
                  + str_xml()
                  ...
          }

          SrcmlXmlWrapper <|... SrcmlXmlWrapper: opt(parent)
          SrcmlXmlWrapper *-- ET.Element
          SrcmlXmlWrapper o-- SrcmlOptions

          class CppElement {
                  + str_code()
                  + visit...()
          }

          class CppElementComments {
                  comment_on_previous_lines: str
                  comment_end_of_line: str
          }

          CppElement --|> SrcmlXmlWrapper

          class CppElementAndComment {
                  cpp_element_comments
          }
          CppElementAndComment --|> CppElement
          CppElementAndComment *-- CppElementComments


          /'
          CppEmptyLine --|> CppElementAndComment
          CppUnprocessed--|> CppElementAndComment
          '/

          class CppBlock {
                  block_children: List[CppElementAndComment]
          }

          CppBlock *-- CppElementAndComment : List

          class CppUnit {
                  "Represent a full file"
          }
          CppUnit --|> CppBlock

          class CppBlockContent {
                  "used by function and anonymous blocks"
          }

          CppBlockContent --|> CppBlock


          class CppPublicProtectedPrivate {
                  + access_type
                  + default_or_explicit
          }
          CppPublicProtectedPrivate --|> CppBlock

          class CppType {
                  typenames: List[str]
                  specifiers: List[str]
                  modifiers: List[str]
          }

          CppType --|> CppElement

          class  CppDecl {
                  cpp_type: CppType
                  decl_name: str
                  c_array_code: str
                  initial_value_code: str
          }

          CppDecl *-- CppType
          CppDecl --|> CppElementAndComment

          class CppDeclStatement {
                  cpp_decls: List[CppDecl]
          }

          CppDeclStatement --|> CppElementAndComment
          CppDeclStatement *-- CppDecl : List

          class CppParameter {
                  decl: CppDecl
                  template_type: CppType
                  template_name: str = ""
          }
          CppParameter --|> CppElementAndComment
          CppParameter *-- CppDecl


          class CppParameterList {
                  List of parameters of a function
                  parameters: List[CppParameter]
          }

          CppParameterList *-- "many" CppParameter

          class CppTemplate {
                  "Template parameters"
                  + parameter_list: CppParameterList
          }
          CppTemplate *-- CppParameterList
          CppTemplate --|> CppElement


          class CppFunctionDecl {
                  "function or method"
                  specifiers: List[str]
                  return_type: CppType
                  parameter_list: CppParameterList
                  template: CppTemplate
                  is_auto_decl: bool
                  function_name: str
          }

          CppFunctionDecl --|> CppElementAndComment
          /' CppFunctionDecl *-- CppType: return_type '/
          CppFunctionDecl *-- CppParameterList
          CppFunctionDecl *-- CppTemplate : optional


          class CppFunction {
                  block
          }
          CppFunction --|> CppFunctionDecl
          CppFunction *-- CppBlockContent

          CppConstructorDecl --|> CppFunctionDecl
          CppContructor --|> CppFunction

          /'
          class CppSuper {
                  specifier
                  superclass_name
          }
          '/

          class CppSuperList {
                  super_list: List[CppSuper]
          }
          /'CppSuperList *-- "many" CppSuper'/
          CppSuperList --|> CppElement


          class CppStruct {
                  class_name: str
                  super_list: CppSuperList
                  block: CppBlock
                  template: CppTemplate

                  +get_public_blocks()
                  +get_public_elements()
                  ...
          }
          CppStruct *-- CppBlock
          CppStruct *-- CppTemplate
          CppStruct *-- CppSuperList

          CppClass --|> CppStruct


          /'CppComment --|> CppElementAndComment'/

          class CppNamespace {
                  ns_name: str
                  block: CppBlock
          }
          CppNamespace --|> CppElementAndComment
          CppNamespace *-- CppBlock

          class CppEnum {
                  block: CppBlock
                  enum_type
                  enum_name
          }

          CppEnum --|> CppElementAndComment
          CppEnum *-- CppBlock
  }


  package litgen {

          class LitgenOptions {
          }

          class AdaptedElement {
                  _cpp_element: CppElementAndComment
                  options: LitgenOptions
                  +str_stub()
                  +str_pydef()
          }
          AdaptedElement *-- CppElementAndComment
          AdaptedElement o-- LitgenOptions

          class AdaptedBlock
          AdaptedBlock --|> AdaptedElement
          AdaptedBlock ... CppBlock

          class AdaptedNamespace
          AdaptedNamespace --|> AdaptedElement
          AdaptedNamespace ... CppNamespace

          class AdaptedDecl
          AdaptedDecl --|> AdaptedElement
          AdaptedDecl ... CppDecl

          AdaptedClassMember --|> AdaptedDecl

          class AdaptedClass {
                  adapted_public_children
          }
          AdaptedClass ... CppClass
          AdaptedClass --|> AdaptedElement
          AdaptedClass *-- AdaptedClassMember: members
          AdaptedClass *-- AdaptedFunction: methods

          AdaptedParameter --|> AdaptedElement
          AdaptedParameter ... CppParameter

          class AdaptedFunction {
                  return_value_policy
                  ...
          }
          AdaptedFunction --|> AdaptedElement
          AdaptedFunction o... CppFunctionDecl

  }

#+end_src

#+RESULTS:
[[file:packages/srcmlcpp/doc/srcml_cpp_diagram.png]]


insert diagram via mermaid (see integration with emacs)


* simple task list

** Do we support constructors? (_str_stub_lines(self) -> List[str]: raise ValueError("To be completed"))
** Rename SrcmlWrapper. _show_element_info => warning info


* Global

*** [ ] Add pylint or flake8 to precommit (cf  https://stackoverflow.com/questions/73765587/how-to-get-a-warning-about-a-list-being-global-when-used-as-a-default-argument))


* Litgen TODO

** Handle namespaces

*** First handle subclasses & sub enums

Scope is already accessible via parent?

**** Add Context?
to AdaptedElement, or maybe better to srcmlcmm.CppElemnt

****** [ ] Remember current scope (namespace /class)

Galere en cours avec stockage parent...

0 = {Element: 1} <Element '{http://www.srcML.org/srcML/src}unit' at 0x103eb5540>
1 = {Element: 1} <Element '{http://www.srcML.org/srcML/src}expr' at 0x103eb5680>
2 = {Element: 0} <Element '{http://www.srcML.org/srcML/src}literal' at 0x103eb5720>

#+begin_src python
  def parse_unit(options: SrcmlOptions, element: SrcmlXmlWrapper) -> CppUnit:                        # Return tuple [CppUnit, Modfied Element) ?
      assert element.tag() == "unit"
      cpp_unit = CppUnit(element)
      fill_block(options, element, cpp_unit)


      ###
      def fill_block(options: SrcmlOptions, element: SrcmlXmlWrapper, inout_block_content: CppBlock) -> None:
          last_ignored_child: Optional[CppElementAndComment] = None
          children: List[CppElementAndComment] = srcml_comments.get_children_with_comments(element)


          ###
          def get_children_with_comments(element: SrcmlXmlWrapper) -> List[CppElementAndComment]:
              if element.options.header_filter_preprocessor_regions:
                  element.srcml_xml = filter_preprocessor_regions(element.srcml_xml, element.options.header_guard_suffixes) # Ok, modifies in place element.srcml_xml

                  ###
                  def filter_preprocessor_regions(unit: ET.Element, header_guard_suffixes: List[str]) -> ET.Element:        # OK
                      filtered_unit = copy.deepcopy(unit)                      #  ARGHHHHHH
                      processor = _SrcmlPreprocessorState(header_guard_suffixes)
                      children_to_remove = []

                      for child in filtered_unit:
                          processor.process_tag(child)
                          if processor.shall_ignore():
                              children_to_remove.append(child)

                          for child_to_remove in children_to_remove:
                              filtered_unit.remove(child_to_remove)

                          return filtered_unit


                  result = []
                  children = _group_comments_and_remove_comment_markers(element)


                  ###
                  def _group_comments_and_remove_comment_markers(srcml_code: SrcmlXmlWrapper) -> List[SrcmlXmlWrapper]:   # Nok? Will create srcml_code_grouped and not return it!
                      srcml_code_grouped: SrcmlXmlWrapper = _group_consecutive_comments(srcml_code)


                      ###
                      def _group_consecutive_comments(srcml_code: SrcmlXmlWrapper) -> SrcmlXmlWrapper: # OK, return a SrcmlXmlWrapper with constructed new element (grouped)
                          # srcml_xml_grouped will contain an xml node in which we group the comments
                          # we will need to create a wrapper around it before returning
                          srcml_xml_grouped = ET.Element(srcml_code.srcml_xml.tag)

                          # ... lots of copy.deepcopy with append to srcml_xml_grouped

                          r = SrcmlXmlWrapper(srcml_code.options, srcml_xml_grouped, srcml_code.filename)
                          return r



                      children_comments_grouped: List[SrcmlXmlWrapper] = []

                      for element in srcml_code_grouped.make_wrapped_children():
                          children_comments_grouped.append(element)
                      for element in children_comments_grouped:
                          if element.tag() == "comment":
                              element_text = element.text()
                              if element_text is not None:
                                  element_text = _remove_comment_tokens(element_text)
                                  element.srcml_xml.text = element_text
                      return children_comments_grouped



                  for i, element in enumerate(children):
                      cpp_element_comments = CppElementComments()

                      # ...

                      if shall_append:
                          element_with_comment = CppElementAndComment(element, cpp_element_comments)
                          result.append(element_with_comment)
                 return result


    return result


      # cpp_unit.fill_children_parents()
      return cpp_unit
#+end_src



See AdaptedFunction => replace parent_struct_name by scope
    def __init__(
        self, options: LitgenOptions, function_infos: CppFunctionDecl,
        parent_struct_name: str, is_overloaded: bool
    ) -> None:


AdaptedElement
  added scope:

  scope needed for:
    functions or methods (in lambda)
    class and inner class (in pydef creation)
    enums



Notes: finish imgui test


***** [ ] Define name of class / take into account scope


**** Sample code / namespace
#+NAME code to test
#+begin_src cpp
namespace A
{
    namespace B
    {
        enum class ItemType{ One, Two, Three};
        void FooB(ItemType itemType);
    }

    void FooA(B::ItemType v);
}
#+end_src

*** Strategy
soit https://www.reddit.com/r/learnpython/comments/dek8fy/how_to_create_a_stub_file_for_a_submodule_in_a_c/
soit fake class with staticmethods

**** Définir un  ou des root Namespace
            pour lequel on ne cree pas de submodule
            que faire des fonctions hors namespace: les ignorer?

     côté pybind:
          module_ newsubmodule = m.def_submodule(const char *name, const char *doc = nullptr)

#include "litgensample.h"

#include <pybind11/pybind11.h>
#include <pybind11/numpy.h>
#include <pybind11/stl.h>
#include <stdint.h>


namespace py = pybind11;


void py_init_module_litgensample(py::module& m)
{
    using namespace LiterateGeneratorExample;

    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <autogen:pydef_cpp> // Autogenerated code below! Do not edit!
    struct BoxedUnsignedLong
    {
        unsigned long value;
        BoxedUnsignedLong() : value{} {}
        BoxedUnsignedLong(unsigned long v) : value(v) {}
        std::string __repr__() { return std::string("BoxedUnsignedLong(") + std::to_string(value) + ")"; }
    };
    struct BoxedInt
    {
        int value;
        BoxedInt() : value{} {}
        BoxedInt(int v) : value(v) {}
        std::string __repr__() { return std::string("BoxedInt(") + std::to_string(value) + ")"; }
    };



    auto pyClassBoxedUnsignedLong = py::class_<BoxedUnsignedLong>    // example_library/litgensample.h:1
        (m, "BoxedUnsignedLong", "")
        .def_readwrite("value", &BoxedUnsignedLong::value, "")    // example_library/litgensample.h:3
        .def(py::init<>())    // example_library/litgensample.h:4
        .def(py::init<unsigned long>(),    // example_library/litgensample.h:5
            py::arg("v"))
        .def("__repr__",    // example_library/litgensample.h:6
            [](BoxedUnsignedLong & self)
            {
                return self.__repr__();
            }
        )
        ;


    auto pyClassBoxedInt = py::class_<BoxedInt>    // example_library/litgensample.h:1
        (m, "BoxedInt", "")
        .def_readwrite("value", &BoxedInt::value, "")    // example_library/litgensample.h:3
        .def(py::init<>())    // example_library/litgensample.h:4
        .def(py::init<int>(),    // example_library/litgensample.h:5
            py::arg("v"))
        .def("__repr__",    // example_library/litgensample.h:6
            [](BoxedInt & self)
            {
                return self.__repr__();
            }
        )
        ;



    // <namespace LiterateGeneratorExample>    // example_library/litgensample.h:18


    py::enum_<MyEnum>(m, "MyEnum", py::arithmetic(), "A super nice enum\nfor demo purposes ( bool val = True )")    // example_library/litgensample.h:23
        .value("a", MyEnum_a, "This is value a")
        // _SRCML_EMPTY_LINE_
        // Lonely comment
        // _SRCML_EMPTY_LINE_
        .value("b", MyEnum_b, "this is value b")
        // _SRCML_EMPTY_LINE_
        .value("c", MyEnum_c, "This is c\nwith doc on several lines")
    ;    // _SRCML_EMPTY_LINE_
    m.def("add_c_array2",    // example_library/litgensample.h:44
        [](const std::array<int, 2>& values)
        {
            auto add_c_array2_adapt_fixed_size_c_arrays = [](const std::array<int, 2>& values)
            {
                auto r = add_c_array2(values.data());
                return r;
            };

            return add_c_array2_adapt_fixed_size_c_arrays(values);
        },
        py::arg("values"),
        "Tests with Boxed Numbers"
    );


    m.def("log_c_array2",    // example_library/litgensample.h:45
        [](const std::array<int, 2>& values)
        {
            auto log_c_array2_adapt_fixed_size_c_arrays = [](const std::array<int, 2>& values)
            {
                log_c_array2(values.data());
            };

            log_c_array2_adapt_fixed_size_c_arrays(values);
        },
        py::arg("values")
    );


    m.def("change_c_array2",    // example_library/litgensample.h:46
        [](BoxedUnsignedLong & values_0, BoxedUnsignedLong & values_1)
        {
            auto change_c_array2_adapt_fixed_size_c_arrays = [](BoxedUnsignedLong & values_0, BoxedUnsignedLong & values_1)
            {
                unsigned long values_raw[2];
                values_raw[0] = values_0.value;
                values_raw[1] = values_1.value;

                change_c_array2(values_raw);

                values_0.value = values_raw[0];
                values_1.value = values_raw[1];
            };

            change_c_array2_adapt_fixed_size_c_arrays(values_0, values_1);
        },
        py::arg("values_0"),
        py::arg("values_1")
    );



    auto pyClassPoint2 = py::class_<Point2>    // example_library/litgensample.h:52
        (m, "Point2", "Test with C array containing user defined struct (which will not be boxed)")
        .def(py::init<>()) // implicit default constructor
        .def_readwrite("x", &Point2::x, "")    // example_library/litgensample.h:54
        .def_readwrite("y", &Point2::y, "")    // example_library/litgensample.h:54
        ;

    m.def("get_points",    // example_library/litgensample.h:56
        [](Point2 & out_0, Point2 & out_1)
        {
            auto GetPoints_adapt_fixed_size_c_arrays = [](Point2 & out_0, Point2 & out_1)
            {
                Point2 out_raw[2];
                out_raw[0] = out_0;
                out_raw[1] = out_1;

                GetPoints(out_raw);

                out_0 = out_raw[0];
                out_1 = out_raw[1];
            };

            GetPoints_adapt_fixed_size_c_arrays(out_0, out_1);
        },
        py::arg("out_0"),
        py::arg("out_1")
    );


    m.def("add_inside_array",    // example_library/litgensample.h:63
        [](py::array & array, uint8_t number_to_add)
        {
            // convert array (py::array&) to C standard buffer (mutable)
            void* array_buffer = array.mutable_data();
            int array_count = array.shape()[0];
            
            char array_type = array.dtype().char_();
            if (array_type != 'B')
                throw std::runtime_error(std::string(R"msg(
                        Bad type!  Expected a buffer of native type:
                                    uint8_t *
                                Which is equivalent to 
                                    B
                                (using py::array::dtype().char_() as an id)
                    )msg"));

            add_inside_array(static_cast<uint8_t *>(array_buffer), array_count, number_to_add);
        },
        py::arg("array"),
        py::arg("number_to_add"),
        "Modify an array by adding a value to its elements (non template function)"
    );


    m.def("mul_inside_array",    // example_library/litgensample.h:69
        [](py::array & array, double factor)
        {
            // convert array (py::array&) to C standard buffer (mutable)
            void* array_buffer = array.mutable_data();
            int array_count = array.shape()[0];
            
            char array_type = array.dtype().char_();
            if (array_type == 'B')
                return mul_inside_array(static_cast<uint8_t*>(array_buffer), array_count, factor);
            else if (array_type == 'b')
                return mul_inside_array(static_cast<int8_t*>(array_buffer), array_count, factor);
            else if (array_type == 'H')
                return mul_inside_array(static_cast<uint16_t*>(array_buffer), array_count, factor);
            else if (array_type == 'h')
                return mul_inside_array(static_cast<int16_t*>(array_buffer), array_count, factor);
            else if (array_type == 'I')
                return mul_inside_array(static_cast<uint32_t*>(array_buffer), array_count, factor);
            else if (array_type == 'i')
                return mul_inside_array(static_cast<int32_t*>(array_buffer), array_count, factor);
            else if (array_type == 'L')
                return mul_inside_array(static_cast<uint64_t*>(array_buffer), array_count, factor);
            else if (array_type == 'l')
                return mul_inside_array(static_cast<int64_t*>(array_buffer), array_count, factor);
            else if (array_type == 'f')
                return mul_inside_array(static_cast<float*>(array_buffer), array_count, factor);
            else if (array_type == 'd')
                return mul_inside_array(static_cast<double*>(array_buffer), array_count, factor);
            else if (array_type == 'g')
                return mul_inside_array(static_cast<long double*>(array_buffer), array_count, factor);

            // If we reach this point, the array type is not supported!
            throw std::runtime_error(std::string("Bad array type: ") + array_type );
        },
        py::arg("array"),
        py::arg("factor"),
        "Modify an array by multiplying its elements (template function!)"
    );


    m.def("c_string_list_total_size",    // example_library/litgensample.h:79
        [](const std::vector<std::string> & items, BoxedInt & output_0, BoxedInt & output_1)
        {
            auto c_string_list_total_size_adapt_fixed_size_c_arrays = [](const char * const items[], int items_count, BoxedInt & output_0, BoxedInt & output_1)
            {
                int output_raw[2];
                output_raw[0] = output_0.value;
                output_raw[1] = output_1.value;

                auto r = c_string_list_total_size(items, items_count, output_raw);

                output_0.value = output_raw[0];
                output_1.value = output_raw[1];

                return r;
            };
            auto c_string_list_total_size_adapt_c_string_list = [&c_string_list_total_size_adapt_fixed_size_c_arrays](const std::vector<std::string> & items, BoxedInt & output_0, BoxedInt & output_1)
            {
                std::vector<const char *> items_ptrs;
                for (const auto& v: items)
                    items_ptrs.push_back(v.c_str());
                int items_count = static_cast<int>(items.size());

                auto r = c_string_list_total_size_adapt_fixed_size_c_arrays(items_ptrs.data(), items_count, output_0, output_1);
                return r;
            };

            return c_string_list_total_size_adapt_c_string_list(items, output_0, output_1);
        },
        py::arg("items"),
        py::arg("output_0"),
        py::arg("output_1")
    );


    m.def("add",    // example_library/litgensample.h:91
        [](int a, int b)
        {
            return add(a, b);
        },
        py::arg("a"),
        py::arg("b"),
        "Adds two numbers"
    );


    m.def("add",    // example_library/litgensample.h:94
        [](int a, int b, int c)
        {
            return add(a, b, c);
        },
        py::arg("a"),
        py::arg("b"),
        py::arg("c"),
        "Adds three numbers, with a surprise"
    );


    m.def("sub",    // example_library/litgensample.h:97
        [](int a, int b)
        {
            return sub(a, b);
        },
        py::arg("a"),
        py::arg("b")
    );


    m.def("mul",    // example_library/litgensample.h:99
        [](int a, int b)
        {
            return mul(a, b);
        },
        py::arg("a"),
        py::arg("b")
    );



    auto pyClassFoo = py::class_<Foo>    // example_library/litgensample.h:102
        (m, "Foo", "A superb struct")
        .def(py::init<>())    // example_library/litgensample.h:104
        .def_property("values",
            [](Foo &self) -> pybind11::array
            {
                auto dtype = pybind11::dtype(pybind11::format_descriptor<int>::format());
                auto base = pybind11::array(dtype, {2}, {sizeof(int)});
                return pybind11::array(dtype, {2}, {sizeof(int)}, self.values, base);
            }, [](Foo& self) {})
        .def_property("flags",
            [](Foo &self) -> pybind11::array
            {
                auto dtype = pybind11::dtype(pybind11::format_descriptor<bool>::format());
                auto base = pybind11::array(dtype, {3}, {sizeof(bool)});
                return pybind11::array(dtype, {3}, {sizeof(bool)}, self.flags, base);
            }, [](Foo& self) {})
        .def_readwrite("factor", &Foo::factor, "Multiplication factor")    // example_library/litgensample.h:118
        .def_readwrite("delta", &Foo::delta, "addition factor")    // example_library/litgensample.h:121
        .def("calc",    // example_library/litgensample.h:128
            [](Foo & self, int x)
            {
                return self.calc(x);
            },
            py::arg("x"),
            "Do some math"
        )
        .def("instance",    // example_library/litgensample.h:130
            [](Foo & self)
            {
                return self.Instance();
            },
            "return_value_policy::reference",
            pybind11::return_value_policy::reference
        )
        ;

    m.def("foo_instance",    // example_library/litgensample.h:133
        []()
        {
            return FooInstance();
        },
        "return_value_policy::reference",
        pybind11::return_value_policy::reference
    );

    // </namespace LiterateGeneratorExample>

    // </autogen:pydef_cpp> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

}
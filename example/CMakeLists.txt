cmake_minimum_required(VERSION 3.2)
project(litgensample)

# Add pybind11
add_subdirectory(external/pybind11)


set(CMAKE_CXX_STANDARD 20)

set(cpp_lib_name litgensample_library)
set(python_module_name litgensample)
set(autgenerate_name litgensample_autogen)


#
# Build Bound C++ library (this is just a dummy example external library)
#
set(cpp_lib_sources bound_library/litgensample.cpp bound_library/litgensample.h)
add_library(${cpp_lib_name} ${cpp_lib_sources})
target_include_directories(${cpp_lib_name} PUBLIC ${CMAKE_CURRENT_LIST_DIR}/bound_library)


#
# Auto-generate the C++ binding code before building the python module
#
add_custom_target(
    ${autgenerate_name}
    COMMAND ${PYTHON_EXECUTABLE} ${CMAKE_CURRENT_LIST_DIR}/autogenerate_litgensample.py
    DEPENDS ${CMAKE_CURRENT_LIST_DIR}/bound_library/litgensample.h
    COMMENT "autogenerate python bindings"

    # We can't use BYPRODUCTS, since
    # "The Makefile Generators will remove BYPRODUCTS and other GENERATED files during make clean."
    # (cf. https://cmake.org/cmake/help/latest/command/add_custom_target.html)
)
# ${autgenerate_name} is run before building the C++ library ${cpp_lib_name}
add_dependencies(${cpp_lib_name} ${autgenerate_name})


#
# Build python module that uses the library
#
set(python_module_sources binding_autogenerated/module.cpp binding_autogenerated/pybind_litgensample.cpp)
pybind11_add_module(${python_module_name} ${python_module_sources})
target_link_libraries(${python_module_name} PRIVATE ${cpp_lib_name})

install(TARGETS ${python_module_name} DESTINATION .)

#
# Copy the python module to the project dir post build (for editable mode)
#
add_custom_command(
    TARGET ${python_module_name}
    POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy
    $<TARGET_FILE:${python_module_name}>
    ${CMAKE_CURRENT_LIST_DIR}/binding_autogenerated/litgensample/$<TARGET_FILE_NAME:${python_module_name}>
)

from typing import List, Optional

from codemanip import code_utils

from litgen.options import LitgenOptions
from litgen.internal import cpp_to_python
from litgen.code_to_adapted_unit import code_to_adapted_unit
from litgen._generated_code import GeneratedBoxedTypeCode


class _BoxedImmutablePythonTypeRegistry:
    cpp_boxed_types: List[str]

    def __init__(self) -> None:
        self.cpp_boxed_types = []

    def register_cpp_type(self, cpp_type: str) -> None:
        if cpp_type not in self.cpp_boxed_types:
            self.cpp_boxed_types.append(cpp_type)

    def has_boxed_types(self) -> bool:
        nb_types = len(self.cpp_boxed_types)
        return nb_types > 0

    def clear(self) -> None:
        self.cpp_boxed_types = []

    def _surround_code_with_marker(self, code: str, comment_token: str) -> str:
        marker = "Autogenerated_Boxed_Types"
        in_marker = f"{comment_token} <{marker}>\n"
        out_marker = f"{comment_token} </{marker}>\n"
        r = in_marker + code + out_marker
        return r

    def generated_code(self, options: LitgenOptions) -> Optional[GeneratedBoxedTypeCode]:
        if not self.has_boxed_types():
            return None

        options_boxed = LitgenOptions()
        options_boxed.python_indent_size = options.python_indent_size
        options_boxed.cpp_indent_size = options.cpp_indent_size
        options_boxed.python_ident_with_tabs = options.cpp_indent_with_tabs
        options_boxed.cpp_indent_with_tabs = options.cpp_indent_with_tabs

        r = GeneratedBoxedTypeCode()

        for cpp_type in self.cpp_boxed_types:
            boxed_type = _BoxedImmutablePythonType_No_Registry(cpp_type)
            r.generated_code.stub_code += boxed_type.stub_code(options_boxed)
            r.generated_code.pydef_code += boxed_type.pydef_code(options_boxed)
            r.boxed_types_cpp_declaration += boxed_type.cpp_header_code(options_boxed)

        r.generated_code.stub_code = self._surround_code_with_marker(r.generated_code.stub_code, "#")
        r.generated_code.pydef_code = self._surround_code_with_marker(r.generated_code.pydef_code, "//")
        r.boxed_types_cpp_declaration = self._surround_code_with_marker(r.boxed_types_cpp_declaration, "//")

        return r


class _BoxedImmutablePythonType_No_Registry:
    cpp_type: str

    def __init__(self, cpp_type: str) -> None:
        if not cpp_to_python.is_cpp_type_immutable_for_python(cpp_type):
            raise TypeError(f"BoxedImmutablePythonType({cpp_type}) is seemingly not immutable")
        self.cpp_type = cpp_type

    def boxed_type_name(self) -> str:
        cpp_type = self.cpp_type
        if cpp_type == "std::string":
            cpp_type = "string"
        boxed_name = "Boxed" + cpp_to_python.cpp_type_to_camel_case_no_space(cpp_type)
        return boxed_name

    def cpp_header_code(self, options: LitgenOptions) -> str:
        cpp_type_default_value = cpp_to_python.cpp_type_default_python_value(self.cpp_type)
        assert cpp_type_default_value is not None

        struct_name = self.boxed_type_name()
        _i_ = options.indent_cpp_spaces()

        std_to_string_value = "std::to_string(value)"
        if self.cpp_type in ["string", "std::string"]:
            std_to_string_value = "value"

        struct_code = f"""
            struct {struct_name}
            {{
            {_i_}{self.cpp_type} value;
            {_i_}{struct_name}({self.cpp_type} v = {cpp_type_default_value}) : value(v) {{}}
            {_i_}std::string __repr__() const {{ return std::string("{struct_name}(") + {std_to_string_value} + ")"; }}
            }};
        """
        struct_code = code_utils.unindent_code(struct_code, flag_strip_empty_lines=True) + "\n"
        return struct_code

    def pydef_code(self, options: LitgenOptions) -> str:
        cpp_header_code = self.cpp_header_code(options)
        adapted_unit = code_to_adapted_unit(options, cpp_header_code)
        pydef_code = adapted_unit.str_pydef()
        return pydef_code

    def stub_code(self, options: LitgenOptions):
        cpp_header_code = self.cpp_header_code(options)
        adapted_unit = code_to_adapted_unit(options, cpp_header_code)
        stub_code = adapted_unit.str_stub()
        return stub_code


_REGISTRY = _BoxedImmutablePythonTypeRegistry()


def clear_registry() -> None:
    _REGISTRY.clear()


def all_boxed_types_generated_code(options: LitgenOptions) -> Optional[GeneratedBoxedTypeCode]:
    r = _REGISTRY.generated_code(options)
    return r


class BoxedImmutablePythonType(_BoxedImmutablePythonType_No_Registry):
    def __init__(self, cpp_type: str) -> None:
        super().__init__(cpp_type)
        _REGISTRY.register_cpp_type(cpp_type)

from typing import List, Optional
import copy

from codemanip import code_utils

from litgen.options import LitgenOptions
from litgen.internal import cpp_to_python
from litgen.code_to_adapted_unit import code_to_adapted_unit
from litgen._generated_code import *


class _BoxedImmutablePythonTypeRegistry:
    cpp_boxed_types: List[str]

    def __init__(self) -> None:
        self.cpp_boxed_types = []

    def register_cpp_type(self, cpp_type: str) -> None:
        if cpp_type not in self.cpp_boxed_types:
            self.cpp_boxed_types.append(cpp_type)

    def has_boxed_types(self) -> bool:
        nb_types = len(self.cpp_boxed_types)
        return nb_types > 0

    def clear(self) -> None:
        self.cpp_boxed_types = []

    def _surround_code_with_marker(self, code: str, comment_token: str) -> str:
        marker = "Autogenerated_Boxed_Types"
        in_marker = f"{comment_token} <{marker}>\n"
        out_marker = f"{comment_token} </{marker}>\n"
        r = in_marker + code + out_marker
        return r

    def generated_code(self, options: LitgenOptions) -> Optional[GeneratedCode]:
        if not self.has_boxed_types():
            return None

        options_no_api = copy.deepcopy(options)
        options_no_api.srcml_options.api_suffixes = []
        options_no_api.srcml_options.functions_api_prefixes = []

        r = GeneratedCode()

        for cpp_type in self.cpp_boxed_types:
            boxed_type = _BoxedImmutablePythonType_No_Registry(cpp_type)
            r.stub_code += boxed_type.stub_code(options_no_api)
            r.pydef_code += boxed_type.pydef_code(options_no_api)
            r.cpp_header_code += boxed_type.cpp_header_code(options_no_api)

        r.stub_code = self._surround_code_with_marker(r.stub_code, "#")
        r.pydef_code = self._surround_code_with_marker(r.pydef_code, "//")
        r.cpp_header_code = self._surround_code_with_marker(r.cpp_header_code, "//")

        return r


class _BoxedImmutablePythonType_No_Registry:
    cpp_type: str

    def __init__(self, cpp_type: str) -> None:
        if not cpp_to_python.is_cpp_type_immutable_for_python(cpp_type):
            raise TypeError(f"BoxedImmutablePythonType({cpp_type}) is seemingly not immutable")
        self.cpp_type = cpp_type

    def boxed_type_name(self) -> str:
        cpp_type = self.cpp_type
        if cpp_type == "std::string":
            cpp_type = "string"
        boxed_name = "Boxed" + cpp_to_python.cpp_type_to_camel_case_no_space(cpp_type)
        return boxed_name

    def cpp_header_code(self, options: LitgenOptions) -> CppHeaderCode:
        cpp_type_default_value = cpp_to_python.cpp_type_default_python_value(self.cpp_type)
        assert cpp_type_default_value is not None

        struct_name = self.boxed_type_name()
        _i_ = options.indent_cpp_spaces()

        struct_code = f"""
            struct {struct_name}
            {{
            {_i_}{self.cpp_type} value;
            {_i_}{struct_name}({self.cpp_type} v = {cpp_type_default_value}) : value(v) {{}}
            {_i_}std::string __repr__() const {{ return std::string("{struct_name}(") + std::to_string(value) + ")"; }}
            }};
        """
        struct_code = code_utils.unindent_code(struct_code, flag_strip_empty_lines=True) + "\n"
        return struct_code

    def pydef_code(self, options: LitgenOptions) -> CppPydefCode:
        cpp_header_code = self.cpp_header_code(options)
        adapted_unit = code_to_adapted_unit(options, cpp_header_code)
        pydef_code = adapted_unit.str_pydef()
        return pydef_code

    def stub_code(self, options: LitgenOptions):
        cpp_header_code = self.cpp_header_code(options)
        adapted_unit = code_to_adapted_unit(options, cpp_header_code)
        stub_code = adapted_unit.str_stub()
        return stub_code


_REGISTRY = _BoxedImmutablePythonTypeRegistry()


def clear_registry() -> None:
    _REGISTRY.clear()


def all_boxed_types_generated_code(options: LitgenOptions) -> Optional[GeneratedCode]:
    r = _REGISTRY.generated_code(options)
    return r


class BoxedImmutablePythonType(_BoxedImmutablePythonType_No_Registry):
    def __init__(self, cpp_type: str) -> None:
        super().__init__(cpp_type)
        _REGISTRY.register_cpp_type(cpp_type)

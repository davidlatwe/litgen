from typing import Optional

from codemanip import code_utils

from litgen.options import LitgenOptions
from litgen.internal import cpp_to_python
from litgen.code_to_adapted_unit import code_to_adapted_unit
from litgen.internal.adapted_types.litgen_writer_context import LitgenWriterContext
from litgen._generated_code import GeneratedBoxedTypeCode
from litgen.internal.boxed_python_types_registry import BoxedPythonTypesRegistry


class _BoxedPythonTypeImpl:
    cpp_type: str

    def __init__(self, cpp_type: str) -> None:
        if not cpp_to_python.is_cpp_type_immutable_for_python(cpp_type):
            raise TypeError(f"BoxedImmutablePythonType({cpp_type}) is seemingly not immutable")
        self.cpp_type = cpp_type

    def boxed_type_name(self) -> str:
        cpp_type = self.cpp_type
        if cpp_type == "std::string":
            cpp_type = "string"
        boxed_name = "Boxed" + cpp_to_python.cpp_type_to_camel_case_no_space(cpp_type)
        return boxed_name

    def cpp_header_code(self, lg_writer_context: LitgenWriterContext) -> str:
        cpp_type_default_value = cpp_to_python.cpp_type_default_python_value(self.cpp_type)
        assert cpp_type_default_value is not None

        options = lg_writer_context.options
        struct_name = self.boxed_type_name()
        _i_ = options.indent_cpp_spaces()

        std_to_string_value = "std::to_string(value)"
        if self.cpp_type in ["string", "std::string"]:
            std_to_string_value = "value"

        struct_code = f"""
            struct {struct_name}
            {{
            {_i_}{self.cpp_type} value;
            {_i_}{struct_name}({self.cpp_type} v = {cpp_type_default_value}) : value(v) {{}}
            {_i_}std::string __repr__() const {{ return std::string("{struct_name}(") + {std_to_string_value} + ")"; }}
            }};
        """
        struct_code = code_utils.unindent_code(struct_code, flag_strip_empty_lines=True) + "\n"
        return struct_code

    def pydef_code(self, lg_writer_context: LitgenWriterContext) -> str:
        cpp_header_code = self.cpp_header_code(lg_writer_context)
        adapted_unit = code_to_adapted_unit(lg_writer_context, cpp_header_code)
        pydef_code = adapted_unit.str_pydef()
        return pydef_code

    def stub_code(self, lg_writer_context: LitgenWriterContext):
        cpp_header_code = self.cpp_header_code(lg_writer_context)
        adapted_unit = code_to_adapted_unit(lg_writer_context, cpp_header_code)
        stub_code = adapted_unit.str_stub()
        return stub_code


class BoxedPythonType(_BoxedPythonTypeImpl):
    def __init__(self, registry: BoxedPythonTypesRegistry, cpp_type: str) -> None:
        super().__init__(cpp_type)
        registry.register_cpp_type(cpp_type)


def generated_code_for_registered_boxed_types(
    lg_writer_context: LitgenWriterContext,
) -> Optional[GeneratedBoxedTypeCode]:

    cpp_boxed_types = lg_writer_context.boxed_types_registry.cpp_boxed_types

    if len(cpp_boxed_types) == 0:
        return None

    def _surround_code_with_marker(code: str, comment_token: str) -> str:
        marker = "Autogenerated_Boxed_Types"
        in_marker = f"{comment_token} <{marker}>\n"
        out_marker = f"{comment_token} </{marker}>\n"
        r = in_marker + code + out_marker
        return r

    def make_standalone_writer_context() -> LitgenWriterContext:
        options_boxed = LitgenOptions()
        options = lg_writer_context.options
        options_boxed.python_indent_size = options.python_indent_size
        options_boxed.cpp_indent_size = options.cpp_indent_size
        options_boxed.python_ident_with_tabs = options.cpp_indent_with_tabs
        options_boxed.cpp_indent_with_tabs = options.cpp_indent_with_tabs
        _lg_writer_context_boxed = LitgenWriterContext(options_boxed)
        return _lg_writer_context_boxed

    lg_writer_context_boxed = make_standalone_writer_context()

    r = GeneratedBoxedTypeCode()

    for cpp_type in cpp_boxed_types:
        boxed_type = _BoxedPythonTypeImpl(cpp_type)
        r.generated_code.stub_code += boxed_type.stub_code(lg_writer_context_boxed)
        r.generated_code.pydef_code += boxed_type.pydef_code(lg_writer_context_boxed)
        r.boxed_types_cpp_declaration += boxed_type.cpp_header_code(lg_writer_context_boxed)

    r.generated_code.stub_code = _surround_code_with_marker(r.generated_code.stub_code, "#")
    r.generated_code.pydef_code = _surround_code_with_marker(r.generated_code.pydef_code, "//")
    r.boxed_types_cpp_declaration = _surround_code_with_marker(r.boxed_types_cpp_declaration, "//")

    return r

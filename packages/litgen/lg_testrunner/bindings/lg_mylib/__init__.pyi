# type: ignore
import sys
from typing import Literal, List, Any, Optional, Tuple
import numpy as np
from enum import Enum
import numpy

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# <litgen_stub> // Autogenerated code below! Do not edit!
####################    <generated_from:BoxedTypes>    ####################
# <Autogenerated_Boxed_Types>
class BoxedUnsignedLong:
    value: int
    def __init__(self, v: int = 0) -> None:
        pass
    def __repr__(self) -> str:
        pass
class BoxedInt:
    value: int
    def __init__(self, v: int = 0) -> None:
        pass
    def __repr__(self) -> str:
        pass
class BoxedBool:
    value: bool
    def __init__(self, v: bool = False) -> None:
        pass
    def __repr__(self) -> str:
        pass
class BoxedString:
    value: str
    def __init__(self, v: str = "") -> None:
        pass
    def __repr__(self) -> str:
        pass
# </Autogenerated_Boxed_Types>
####################    </generated_from:BoxedTypes>    ####################
####################    <generated_from:mylib_amalgamation.h>    ####################
# THIS FILE WAS GENERATED AUTOMATICALLY. DO NOT EDIT.

#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       mylib/mylib.h                                                                          //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       mylib/api_marker.h included by mylib/mylib.h                                           //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       mylib/header_filter_test.h included by mylib/mylib.h                                   //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

# Here, we test that functions placed under unknown preprocessor defines are not exported by default
# You could choose to add them anyway with:
# ````
#    options.srcml_options.header_guard_suffixes.append("OBSCURE_OPTION")
# ````


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       mylib/c_style_array_test.h included by mylib/mylib.h                                   //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#
# C Style array tests
#

# Tests with Boxed Numbers
def add_c_array2(values: List[int]) -> int:
    pass
def log_c_array2(values: List[int]) -> None:
    pass
def change_c_array2(
    values_0: BoxedUnsignedLong,
    values_1: BoxedUnsignedLong
    ) -> None:
    pass
class Point2:
    """ Test with C array containing user defined struct (which will not be boxed)"""
    x: int
    y: int
def get_points(out_0: Point2, out_1: Point2) -> None:
    pass

#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       mylib/c_style_buffer_to_pyarray_test.h included by mylib/mylib.h                       //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#
# C Style buffer to py::array tests
#

def add_inside_buffer(buffer: np.ndarray, number_to_add: int) -> None:
    """ Modifies a buffer by adding a value to its elements"""
    pass

def buffer_sum(buffer: np.ndarray, stride: int = -1) -> int:
    """ Returns the sum of a const buffer"""
    pass

def add_inside_two_buffers(
    buffer_1: np.ndarray,
    buffer_2: np.ndarray,
    number_to_add: int
    ) -> None:
    """ Modifies two buffers"""
    pass

def mul_inside_buffer(buffer: np.ndarray, factor: float) -> None:
    """ Modify an array by multiplying its elements (template function!)"""
    pass

#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       mylib/c_string_list_test.h included by mylib/mylib.h                                   //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#
# C String lists tests
#

def c_string_list_total_size(
    items: List[str],
    output_0: BoxedInt,
    output_1: BoxedInt
    ) -> int:
    pass

#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       mylib/modifiable_immutable_test.h included by mylib/mylib.h                            //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#
# Modifiable immutable python types test
#

#///////////////////////////////////////////////////////////////////////////////////////////
# Test Part 1: in the functions below, the value parameters will be "Boxed"
#
# This is caused by the following options during generation:
#     options.fn_params_replace_modifiable_immutable_by_boxed__regexes = [
#         r"^Toggle",
#         r"^Modify",
#      ]
#/////////////////////////////////////////////////////////////////////////////////////////


def toggle_bool_pointer(v: BoxedBool) -> None:
    """ Test with pointer
     -->    def toggle_bool_pointer(v: BoxedBool) -> None:
    """
    pass

def toggle_bool_nullable(v: BoxedBool = None) -> None:
    """ Test with nullable pointer
     -->    def toggle_bool_nullable(v: BoxedBool = None) -> None:
    """
    pass

def toggle_bool_reference(v: BoxedBool) -> None:
    """ Test with reference
     -->    def toggle_bool_reference(v: BoxedBool) -> None:
    """
    pass

def modify_string(s: BoxedString) -> None:
    """ Test modifiable String
     -->    def modify_string(s: BoxedString) -> None:
    """
    pass


#///////////////////////////////////////////////////////////////////////////////////////////
#
# Test Part 2: in the functions below, the python return type is modified:
# the python functions will return a tuple:
#     (original_return_value, modified_parameter)
#
# This is caused by the following options during generation:
#
#     options.fn_params_output_modifiable_immutable_to_return__regexes = [r"^Slider"]
#/////////////////////////////////////////////////////////////////////////////////////////


def slider_bool_int(label: str, value: int) -> Tuple[bool, int]:
    """ Test with int param + int return type
     --> def slider_bool_int(label: str, value: int) -> Tuple[bool, int]:
    """
    pass

def slider_void_int(label: str, value: int) -> int:
    """ -->    def slider_void_int(label: str, value: int) -> int:"""
    pass

def slider_bool_int2(
    label: str,
    value1: int,
    value2: int
    ) -> Tuple[bool, int, int]:
    """ -->    def slider_bool_int2(label: str, value1: int, value2: int) -> Tuple[bool, int, int]:"""
    pass

def slider_void_int_default_null(
    label: str,
    value: Optional[int] = None
    ) -> Tuple[bool, Optional[int]]:
    """ -->    def slider_void_int_default_null(label: str, value: Optional[int] = None) -> Tuple[bool, Optional[int]]:"""
    pass

def slider_void_int_array(
    label: str,
    value: List[int]
    ) -> Tuple[bool, List[int]]:
    """ -->    def slider_void_int_array(label: str, value: List[int]) -> Tuple[bool, List[int]]:"""
    pass

#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       mylib/overload_test.h included by mylib/mylib.h                                        //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#
# Test overload
#
def add_overload(a: int, b: int) -> int:  # type: ignore
    pass
def add_overload(a: int, b: int, c: int) -> int:  # type: ignore
    pass

class FooOverload:
    def add_overload(self, a: int, b: int) -> int:          # type: ignore
        pass
    def add_overload(self, a: int, b: int, c: int) -> int:  # type: ignore
        pass

class BasicEnum(Enum):
    """////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                           mylib/enum_test.h included by mylib/mylib.h                                            //
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////
     A super nice enum for demo purposes
    """
    my_enum_a = 1    # This is value a
    my_enum_aa = 2   # this is value aa
    my_enum_aaa = 3  # this is value aaa

    # Lonely comment

    # This is value b
    my_enum_b = 4

    # This is c
    # with doc on several lines
    my_enum_c = Literal[BasicEnum.my_enum_a] | Literal[BasicEnum.my_enum_b]

    # MyEnum_count





#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       mylib/mylib.h continued                                                                //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
# <Namespace LiterateGeneratorExample>

def add(a: int, b: int) -> int:
    """ Adds two numbers"""
    pass

def sub(a: int, b: int) -> int:
    pass

def mul(a: int, b: int) -> int:
    pass

class Foo:
    """ A superb struct"""
    def __init__(self) -> None:
        pass

    #
    # These are our parameters
    #

    #
    # Test with numeric arrays which should be converted to py::array
    #
    values: np.ndarray  # ndarray[type=int, size=2] default:{0, 1}
    flags: np.ndarray   # ndarray[type=bool, size=3] default:{False, True, False}


    # Multiplication factor
    factor: int = 10

    # addition factor
    delta: int

    #
    # And these are our calculations
    #

    def calc(self, x: int) -> int:
        """ Do some math"""
        pass


def foo_instance() -> Foo:
    """return_value_policy::reference"""
    pass





# </Namespace LiterateGeneratorExample>
####################    </generated_from:mylib_amalgamation.h>    ####################

# </litgen_stub>
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
